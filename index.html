<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>부광고등학교 모니터 조사</title>
    <link rel="icon" href="bg.ico" type="image/x-icon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
      /* 기존 스타일 유지 (변경 없음) */
      @font-face { font-family: 'Freesentation-9Black'; src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-9Black.woff2') format('woff2'); font-weight: 900; font-style: normal; }
      @font-face { font-family: 'Pretendard-Regular'; src: url('https://fastly.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Regular.woff') format('woff'); font-weight: 400; font-style: normal; }
      body { font-family: 'Pretendard-Regular', sans-serif; background-color: #F8F9FA; display: flex; flex-direction: column; align-items: center; padding: 60px 20px 20px 20px; color: #333; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; overflow-x: hidden; }
      #button-container { position: fixed; top: 15px; right: 20px; z-index: 1000; display: flex; gap: 10px; }
      .icon-button { padding: 8px 12px; font-size: 14px; cursor: pointer; background-color: #007AFF; color: white; border: none; border-radius: 6px; transition: background-color 0.2s ease; display: inline-flex; align-items: center; gap: 6px; }
      .icon-button span { letter-spacing: -0.05em; }
      .icon-button:hover { background-color: #005ECB; }
      .icon-button:disabled { background-color: #BDBDBD; cursor: not-allowed; }
      .icon-button svg { width: 1em; height: 1em; fill: currentColor; }
      #pdf-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 2000; color: white; font-size: 1.5em; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; text-align: center; }
      #pdf-overlay.visible { opacity: 1; visibility: visible; }
      .floor-plan { display: flex; flex-direction: column; align-items: center; gap: 25px; width: fit-content; margin-top: 10px; transform-origin: center top; transition: transform 0.3s ease; }
      .floor-section { width: fit-content; background-color: #F8F9FA; padding: 22px; border-radius: 8px; box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12); margin-bottom: 10px; }
      .section-divider { border: none; height: 1px; background-color: #DEE2E6; width: 100%; max-width: 930px; margin: 30px 0; }
      .pdf-capture-mode .floor-section { background-color: #FFFFFF !important; box-shadow: none !important; padding: 5px !important; border: none !important; margin-bottom: 0 !important; }
      .pdf-capture-mode .grid-container, .pdf-capture-mode .lost-monitors-grid { background-color: #FFFFFF !important; border-color: #CCCCCC !important; gap: 2px !important; padding: 2px !important; }
      .pdf-capture-mode .cube { background-color: #F0F2F5 !important; border: 1px solid #CCCCCC !important; }
      .pdf-capture-mode .corridor { background-color: #FFFFFF !important; border: 1px dashed #DDDDDD !important; }
      .pdf-capture-mode .section-divider { display: none !important; }
      .pdf-capture-mode .section-label { color: #333333 !important; font-family: 'Freesentation-9Black', sans-serif !important; }
      .pdf-capture-mode body, .pdf-capture-mode .cube, .pdf-capture-mode .icon-button { font-family: 'Pretendard-Regular', sans-serif !important; }
      /* PDF 기본 폰트 스타일 추가 */
      .pdf-capture-mode.pdf-default-font body, .pdf-capture-mode.pdf-default-font .cube, .pdf-capture-mode.pdf-default-font .icon-button { font-family: sans-serif !important; }
      .pdf-capture-mode .cube-name-text { font-weight: 600 !important; }
      .pdf-capture-mode .cube, .pdf-capture-mode .monitor-cube { letter-spacing: -0.05em !important; }
      .pdf-capture-mode .lost-location-cube { background-color: #f8f9fa !important; border: 1px solid #dee2e6 !important; }
      .section-label { font-family: 'Freesentation-9Black', sans-serif; font-size: 24px; font-weight: 900; margin-bottom: 15px; text-align: center; color: #555; }
      .grid-container { display: grid; gap: 3px; border: 1px solid #E0E0E0; border-radius: 8px; background-color: #E0E0E0; padding: 3px; overflow: hidden; grid-auto-rows: minmax(60px, auto); }
      .cube { box-sizing: border-box; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; text-align: center; font-size: 11px; padding: 5px; word-break: keep-all; overflow-wrap: break-word; overflow: hidden; line-height: 1.3; border-radius: 5px; background-color: #FFFFFF; border: 1px solid transparent; transition: background-color 0.2s ease, border-color 0.2s ease; min-height: 60px; letter-spacing: -0.05em; }
      .cube-name { margin-bottom: 4px; width: 100%; }
      .cube-name-text { font-weight: 600; }
      .corridor { background-color: #F0F2F5; border-color: transparent; }
      .cube:not(.corridor):hover { background-color: rgba(0, 122, 255, 0.08); border-color: rgba(0, 122, 255, 0.5); }
      .monitor-list { display: flex; flex-direction: column; gap: 3px; width: 100%; padding-top: 4px; }
      .monitor-cube { box-sizing: border-box; background-color: #E9ECEF; border: 1px solid #DEE2E6; border-radius: 4px; padding: 4px; font-size: 9.5px; color: #495057; width: 100%; text-align: center; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; letter-spacing: -0.05em; }
      .monitor-cube.status-green { background-color: #E8F5E9; border-color: #C8E6C9; color: #1B5E20; }
      .monitor-cube.status-red { background-color: #FFEBEE; border-color: #FFCDD2; color: #B71C1C; }
      .monitor-cube.status-yellow { background-color: #FFFACD; border-color: #FFEC8B; color: #8B7500; }
      .monitor-cube:hover { filter: brightness(95%); }
      #loading-message, #error-message { margin-top: 20px; font-size: 16px; color: #6c757d; white-space: pre-wrap; word-break: break-all; max-width: 80%; text-align: center; letter-spacing: -0.05em; }
      #error-message { color: #dc3545; }
      .lost-monitors-grid { display: grid; gap: 3px; grid-template-columns: repeat(9, 100px); padding: 3px; border: 1px solid #E0E0E0; border-radius: 8px; background-color: #E0E0E0; grid-auto-rows: minmax(60px, auto); width: fit-content; }
      .lost-location-cube { background-color: #ffffff; border: 1px solid transparent; border-radius: 5px; padding: 5px; min-height: 60px; display: flex; flex-direction: column; font-size: 11px; line-height: 1.3; letter-spacing: -0.05em; box-sizing: border-box; justify-content: flex-start; text-align: center; word-break: keep-all; overflow-wrap: break-word; overflow: hidden; }
      .lost-location-name { font-weight: 600; font-size: 11px; margin-bottom: 4px; width: 100%; color: #495057; border-bottom: 1px dashed #e0e0e0; padding-bottom: 3px; }
      .lost-monitor-list { display: flex; flex-direction: column; gap: 3px; width: 100%; padding-top: 4px; }
    </style>
</head>
<body>
    <div id="button-container">
      <button class="icon-button" id="refreshButton" title="새로고침">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.65 6.35A7.958 7.958 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
        <span>새로고침</span>
      </button>
      <button class="icon-button" id="downloadButton" title="PDF 저장">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></svg>
        <span>PDF 저장</span>
      </button>
    </div>

    <div id="pdf-overlay">
      <span>PDF 생성 중...</span>
    </div>

    <div id="loading-message" style="display: none;">데이터 로딩 중...</div>
    <div id="error-message" style="display: none;">데이터 로딩 실패.</div>
    <div class="floor-plan" id="floorPlanContainer"></div>
    <div class="floor-plan" id="lostMonitorsContainer" style="display: none;"></div>

    <script>
      const SHEET_ID = '1g--ydME6sFvsE44He1C4AO4uQRxwOtJm';
      const SHEET_GID = '849721815';
      const SHEET_CSV_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${SHEET_GID}`;

      const COL_INDEX = {
        INSTALL_STATUS: 0, ID: 1, CURRENT_INFO: 2, CURRENT_LOCATION_NAME: 3,
        PREVIOUS_LOCATION: 4, NOTES: 5
      };

      // 학교 구조 데이터 (변경 없음)
      const schoolLayout = [
        { label: '5층', columns: 9, rooms: [{ name: '웅비관', col: 1, row: 1, colSpan: 3 }, { name: '3학년 상담실', col: 4, row: 1 }, { name: '푸르미르터3', col: 6, row: 1, colSpan: 2 }, { name: '혜움터3', col: 6, row: 2 }, { name: '서로나눔3', col: 6, row: 3 }, { name: '교재연구실', col: 6, row: 4 }, { name: '3-8', col: 1, row: 5 }, { name: '3-7', col: 2, row: 5 }, { name: '3-6', col: 3, row: 5 }, { name: '3-5', col: 4, row: 5 }, { name: '3학년 연구실', col: 5, row: 5 }, { name: '3-4', col: 6, row: 5 }, { name: '3-3', col: 7, row: 5 }, { name: '3-2', col: 8, row: 5 }, { name: '3-1', col: 9, row: 5 }], corridors: [{ col: 5, row: 1 }, { col: 5, row: 2 }, { col: 5, row: 3 }, { col: 5, row: 4 }] },
        { label: '4층', columns: 9, rooms: [{ name: 'AI융합ON', col: 1, row: 1 }, { name: '여교직원 휴게실', col: 2, row: 1 }, { name: '학생자치실', col: 3, row: 1 }, { name: '2학년 상담실', col: 4, row: 1 }, { name: '푸르미르터2', col: 6, row: 1, colSpan: 2 }, { name: '혜움터2', col: 6, row: 2 }, { name: '서로나눔2', col: 6, row: 3 }, { name: '사회교과교실', col: 1, row: 5 }, { name: '2-7', col: 2, row: 5 }, { name: '2-6', col: 3, row: 5 }, { name: '2-5', col: 4, row: 5 }, { name: '2학년 연구실', col: 5, row: 5 }, { name: '2-4', col: 6, row: 5 }, { name: '2-3', col: 7, row: 5 }, { name: '2-2', col: 8, row: 5 }, { name: '2-1', col: 9, row: 5 }], corridors: [{ col: 5, row: 1 }, { col: 5, row: 2 }, { col: 5, row: 3 }, { col: 5, row: 4 }, { col: 6, row: 4 }] },
        { label: '3층', columns: 9, rooms: [{ name: '나눔ON', col: 1, row: 1 }, { name: '이룸ON', col: 2, row: 1 }, { name: '진로진학부', col: 3, row: 1 }, { name: '1학년 상담실', col: 4, row: 1 }, { name: '푸르미르터1', col: 6, row: 1, colSpan: 2 }, { name: '혜움터1', col: 6, row: 2 }, { name: '서로나눔1', col: 6, row: 3 }, { name: '부광마실', col: 1, row: 5 }, { name: '1-7', col: 2, row: 5 }, { name: '1-6', col: 3, row: 5 }, { name: '1-5', col: 4, row: 5 }, { name: '1학년 연구실', col: 5, row: 5 }, { name: '1-4', col: 6, row: 5 }, { name: '1-3', col: 7, row: 5 }, { name: '1-2', col: 8, row: 5 }, { name: '1-1', col: 9, row: 5 }], corridors: [{ col: 5, row: 1 }, { col: 5, row: 2 }, { col: 5, row: 3 }, { col: 5, row: 4 }, { col: 6, row: 4 }] },
        { label: '2층', columns: 9, rooms: [{ name: '지능형 과학실', col: 1, row: 1, colSpan: 2 }, { name: '사이언스디자인랩', col: 3, row: 1, colSpan: 2 }, { name: '열림ON', col: 6, row: 1, colSpan: 2 }, { name: '창의ON', col: 6, row: 2 }, { name: '서버실', col: 6, row: 3 }, { name: '미디어실', col: 1, row: 5 }, { name: '방송실', col: 2, row: 5 }, { name: '소담소담', col: 3, row: 5 }, { name: '리딩실', col: 4, row: 5 }, { name: '교무지원센터', col: 5, row: 5 }, { name: '교장실', col: 6, row: 5 }, { name: '생활안전부', col: 7, row: 5 }, { name: '통합교육지원실1', col: 8, row: 5 }, { name: '위클래스', col: 9, row: 5 }], corridors: [{ col: 5, row: 1 }, { col: 5, row: 2 }, { col: 5, row: 3 }, { col: 5, row: 4 }, { col: 6, row: 4 }] },
        { label: '1층', columns: 9, rooms: [{ name: '물리지학실', col: 1, row: 1, colSpan: 2 }, { name: '사이언스라운지', col: 3, row: 1, colSpan: 2 }, { name: '생명화학실', col: 6, row: 1, colSpan: 2 }, { name: '비품실', col: 6, row: 2 }, { name: '기계실', col: 6, row: 3 }, { name: '샤워실', col: 6, row: 4 }, { name: '보건실', col: 1, row: 5 }, { name: '통합교육지원실2', col: 2, row: 5 }, { name: '인쇄실', col: 3, row: 5 }, { name: '행정실', col: 4, row: 5 }, { name: '숙직실', col: 6, row: 5 }, { name: '도서관', col: 7, row: 5, colSpan: 3 }, { name: '급식소', col: 8, row: 3 }], corridors: [{ col: 5, row: 1 }, { col: 5, row: 2 }, { col: 5, row: 3 }, { col: 5, row: 4 }, { col: 5, row: 5 }] },
        { label: '체육관', columns: 3, rooms: [{ name: '미술준비실', col: 1, row: 1 }, { name: '음악실', col: 3, row: 1 }, { name: '미술실', col: 1, row: 2 }, { name: '체육교육부', col: 3, row: 2 }, { name: '배움터지킴이실', col: 3, row: 3 }], corridors: [{ col: 2, row: 1 }, { col: 2, row: 2 }] }
      ];

      const floorPlanContainer = document.getElementById('floorPlanContainer');
      const lostMonitorsContainer = document.getElementById('lostMonitorsContainer');
      const refreshButton = document.getElementById('refreshButton');
      const downloadButton = document.getElementById('downloadButton');
      const loadingMessage = document.getElementById('loading-message');
      const errorMessage = document.getElementById('error-message');
      const pdfOverlay = document.getElementById('pdf-overlay');

      let validLocations = new Map();
      const { jsPDF } = window.jspdf;
      let resizeTimeout;

      function buildValidLocations() {
        validLocations = new Map();
        schoolLayout.forEach(floor => {
          floor.rooms?.forEach(room => {
            validLocations.set(`${floor.label} ${room.name}`, { label: floor.label, name: room.name });
          });
        });
      }

      // *** 수정된 CSV 파싱 함수 ***
      function parseCSV(text) {
          const rows = [];
          let currentRow = [];
          let currentField = '';
          let inQuotes = false;
          // 줄바꿈 문자 정규화 (\r\n, \r -> \n)
          text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          // 마지막 줄에 개행 문자가 없어도 처리되도록 끝에 \n 추가 (선택적)
          if (text.length > 0 && text[text.length - 1] !== '\n') {
              text += '\n';
          }

          for (let i = 0; i < text.length; i++) {
              const char = text[i];
              const nextChar = text[i + 1];

              if (!inQuotes) {
                  if (char === '"') {
                      // 따옴표 시작 (필드 시작 부분의 따옴표는 무시)
                      if (currentField === '') {
                           inQuotes = true;
                      } else {
                          // 필드 중간의 따옴표는 일단 내용으로 추가 (오류 가능성 있음)
                          // CSV 표준에 따라서는 필드 중간에 따옴표가 나오면 안됨.
                          currentField += char;
                      }
                  } else if (char === ',') {
                      // 필드 구분자
                      currentRow.push(currentField);
                      currentField = '';
                  } else if (char === '\n') {
                      // 행 구분자
                      currentRow.push(currentField); // 현재 필드 추가
                      // 헤더 행이 아니거나, 내용이 있는 행만 추가
                      if (rows.length > 0 || currentRow.some(field => field !== '')) {
                           rows.push(currentRow);
                      }
                      currentRow = [];
                      currentField = '';
                  } else {
                      // 일반 문자
                      currentField += char;
                  }
              } else { // Inside quotes
                  if (char === '"') {
                      if (nextChar === '"') {
                          // 이스케이프된 따옴표 "" -> " 하나로 처리
                          currentField += '"';
                          i++; // 다음 따옴표 건너뛰기
                      } else {
                          // 따옴표 종료
                          inQuotes = false;
                          // 따옴표 뒤에 바로 쉼표나 개행이 아닌 문자가 오면 표준 위반이지만, 일단 허용
                      }
                  } else {
                      // 따옴표 안의 모든 문자 (쉼표, 개행 포함) 추가
                      currentField += char;
                  }
              }
          }

          // 헤더 행(첫 번째 행) 제거 후 데이터 반환
          if (rows.length > 0) {
            return { data: rows.slice(1) };
          } else {
            return { data: [] };
          }
      }

      // Helper function to normalize data to '?'
      function normalizeValue(value) {
          const trimmedValue = value?.trim();
          return (!trimmedValue || trimmedValue.toUpperCase() === 'N/A') ? '?' : trimmedValue;
      }

      async function loadAndRenderLayout() {
        refreshButton.disabled = true; downloadButton.disabled = true;
        loadingMessage.style.display = 'block'; errorMessage.style.display = 'none';
        floorPlanContainer.innerHTML = ''; lostMonitorsContainer.innerHTML = '';
        lostMonitorsContainer.style.display = 'none';

        let allMonitors = [], monitorsByLocation = {}, monitorCounts = {},
            monitorsCountPerFloor = {}, lostMonitors = [];

        try {
          const fetchUrl = `${SHEET_CSV_URL}&_=${new Date().getTime()}`;
          const response = await fetch(fetchUrl);
          if (!response.ok) throw new Error(`HTTP 오류! 상태: ${response.status}`);
          const csvText = await response.text();
          const { data } = parseCSV(csvText); // 수정된 파서 사용

          if (data.length === 0) console.warn("시트 데이터가 비어있습니다.");

          allMonitors = data.map(row => {
            // CSV 파싱 결과가 row 배열이 아닐 수 있으므로 방어 코드 추가
            if (!Array.isArray(row)) {
                console.warn("잘못된 형식의 행 데이터:", row);
                return null; // 잘못된 데이터는 null 반환
            }
            const currentInfo = row[COL_INDEX.CURRENT_INFO] || '';
            const parts = currentInfo.split('/');
            return {
              installStatus: normalizeValue(row[COL_INDEX.INSTALL_STATUS]).toUpperCase(),
              id: normalizeValue(row[COL_INDEX.ID]),
              building: parts[0]?.trim() || 'UB',
              floor: parts[1]?.trim() || 'UF',
              current: normalizeValue(row[COL_INDEX.CURRENT_LOCATION_NAME]),
              previous: normalizeValue(row[COL_INDEX.PREVIOUS_LOCATION]),
              // 비고(Notes)는 normalizeValue 적용 안 함 (빈 문자열 유지)
              notes: row[COL_INDEX.NOTES] || ''
            };
          }).filter(monitor => monitor !== null); // null 제거

          schoolLayout.forEach(floor => { monitorsCountPerFloor[floor.label] = 0; });

          allMonitors.forEach(monitor => {
            if (monitor.id === '?') {
                console.warn("ID가 '?'인 모니터 데이터 건너뜁니다.");
                return;
            }
            const potentialKey = monitor.building === '체육관' ? `체육관 ${monitor.current}` : `${monitor.floor} ${monitor.current}`;
            if (monitor.current === '?' || !validLocations.has(potentialKey)) {
                lostMonitors.push(monitor);
            } else {
                const currentLocationKey = potentialKey;
                const currentFloorLabel = validLocations.get(currentLocationKey).label;
                monitorCounts[currentLocationKey] = (monitorCounts[currentLocationKey] || 0) + 1;
                if (!monitorsByLocation[currentLocationKey]) monitorsByLocation[currentLocationKey] = [];
                monitorsByLocation[currentLocationKey].push(monitor);
                monitorsCountPerFloor[currentFloorLabel] = (monitorsCountPerFloor[currentFloorLabel] || 0) + 1;
            }
          });

          renderLayout(monitorCounts, monitorsByLocation, monitorsCountPerFloor);

          if (lostMonitors.length > 0) {
              const divider = document.createElement('hr');
              divider.className = 'section-divider';
              floorPlanContainer.appendChild(divider);
              renderLostMonitors(lostMonitors);
          } else {
              adjustRowHeights(); scaleLayout();
          }

          downloadButton.disabled = false;

        } catch (error) {
          console.error("데이터 로딩/처리 오류:", error);
          errorMessage.textContent = `데이터 처리 오류:\n${error.message}`;
          errorMessage.style.display = 'block';
          downloadButton.disabled = true;
        } finally {
          loadingMessage.style.display = 'none';
          refreshButton.disabled = false;
        }
      }

      function createCube(roomData, isCorridor = false, floorLabel = '', monitorCounts, monitorsByLocation) { /* 변경 없음 */
        const cubeDiv = document.createElement('div');
        cubeDiv.className = isCorridor ? 'cube corridor' : 'cube';
        cubeDiv.style.gridColumn = `${roomData.col} / span ${roomData.colSpan || 1}`;
        cubeDiv.style.gridRow = `${roomData.row} / span ${roomData.rowSpan || 1}`;
        cubeDiv.dataset.row = roomData.row;

        if (!isCorridor) {
          const nameDiv = document.createElement('div'); nameDiv.className = 'cube-name';
          const locationKey = `${floorLabel} ${roomData.name}`; const count = monitorCounts[locationKey] || 0;
          nameDiv.innerHTML = `<span class="cube-name-text">${roomData.name}</span> ${count > 0 ? `(${count})` : ''}`;
          cubeDiv.appendChild(nameDiv);
          const monitorsInRoom = monitorsByLocation[locationKey];
          if (monitorsInRoom && monitorsInRoom.length > 0) {
            const monitorListDiv = document.createElement('div'); monitorListDiv.className = 'monitor-list';
            monitorsInRoom.forEach(monitor => { monitorListDiv.appendChild(createMonitorCube(monitor, locationKey)); });
            cubeDiv.appendChild(monitorListDiv);
          }
        } return cubeDiv;
      }

      function createMonitorCube(monitor, locationKey) { /* 변경 없음 */
          const monitorCubeDiv = document.createElement('div');
          monitorCubeDiv.className = 'monitor-cube';
          const displayId = monitor.installStatus !== 'O' ? `[X] ${monitor.id}` : monitor.id;
          monitorCubeDiv.textContent = displayId; monitorCubeDiv.title = monitor.id;
          monitorCubeDiv.classList.remove('status-green', 'status-red', 'status-yellow');
          if (monitor.current !== '?' && monitor.previous === '=') monitorCubeDiv.classList.add('status-green');
          else if (monitor.previous === '?' || monitor.current === '?') monitorCubeDiv.classList.add('status-red');
          else if (monitor.installStatus !== 'O') monitorCubeDiv.classList.add('status-yellow');

          monitorCubeDiv.addEventListener('click', () => {
              let previousLocationDisplay = monitor.previous;
              if (previousLocationDisplay !== '?') {
                  let found = false;
                  for (const [key, value] of validLocations.entries()) { if (value.name === previousLocationDisplay) { previousLocationDisplay = key; found = true; break; } }
              }
              let alertMessage = `고유 번호: ${monitor.id}\n현재 위치: ${locationKey || monitor.current}\n이전 위치: ${previousLocationDisplay}`;
              // 비고(notes)가 있을 때만 추가 (이제 여러 줄 가능)
              if (monitor.notes) alertMessage += `\n비고: ${monitor.notes}`;
              if (monitor.installStatus !== 'O') alertMessage += `\n\n* 현재 사용중이지 않거나 사용 여부를 알 수 없는 모니터 입니다.)`;
              alert(alertMessage);
          }); return monitorCubeDiv;
      }

      function adjustRowHeights() { /* 변경 없음 - 필요시 이전 답변 코드 사용 */
          requestAnimationFrame(() => {
              const gridContainers = document.querySelectorAll('.grid-container, .lost-monitors-grid');
              gridContainers.forEach(grid => {
                  let maxRow = 0;
                  grid.querySelectorAll('.cube[data-row], .lost-location-cube').forEach(cube => {
                      let endRow;
                      if (cube.classList.contains('lost-location-cube')) { return; }
                      else { const rowSpan = parseInt(cube.style.gridRowEnd, 10) - parseInt(cube.style.gridRowStart, 10) || 1; endRow = (parseInt(cube.dataset.row, 10) || 0) + rowSpan -1; }
                      maxRow = Math.max(maxRow, endRow);
                  });
                  if (!maxRow) return;
                  for (let r = 1; r <= maxRow; r++) {
                      let maxHeight = 60; const cubesInRow = [];
                       grid.querySelectorAll('.cube').forEach(cube => {
                            const startRow = parseInt(cube.style.gridRowStart, 10) || parseInt(cube.dataset.row, 10); const rowSpan = parseInt(cube.style.gridRowEnd, 10) - startRow || 1; const endRow = startRow + rowSpan - 1;
                            if (startRow <= r && r <= endRow) { cube.style.minHeight = ''; maxHeight = Math.max(maxHeight, cube.offsetHeight); cubesInRow.push(cube); }
                       });
                      if (maxHeight > 60) { cubesInRow.forEach(cube => { const currentMinHeight = parseInt(cube.style.minHeight) || 0; cube.style.minHeight = `${Math.max(maxHeight, currentMinHeight)}px`; }); }
                      else { cubesInRow.forEach(cube => { const currentMinHeight = parseInt(cube.style.minHeight) || 0; if (currentMinHeight < 60) { cube.style.minHeight = `60px`; } }); }
                  }
                   grid.querySelectorAll('.lost-location-cube').forEach(cube => { if (!cube.style.minHeight) { cube.style.minHeight = '60px'; } });
              });
          });
      }

      function renderLayout(monitorCounts, monitorsByLocation, monitorsCountPerFloor) { /* 변경 없음 */
        floorPlanContainer.innerHTML = '';
        schoolLayout.forEach((floorData, index) => {
          const sectionDiv = document.createElement('div'); sectionDiv.id = `section-${floorData.label.replace(/[^a-zA-Z0-9]/g, '') || index}`; sectionDiv.className = 'floor-section';
          const labelDiv = document.createElement('div'); labelDiv.className = 'section-label';
          const floorMonitorCount = monitorsCountPerFloor[floorData.label] || 0;
          labelDiv.textContent = `${floorData.label}${floorMonitorCount > 0 ? ` (${floorMonitorCount})` : ''}`; sectionDiv.appendChild(labelDiv);
          const gridDiv = document.createElement('div'); gridDiv.className = 'grid-container'; gridDiv.style.gridTemplateColumns = `repeat(${floorData.columns}, 100px)`;
          floorData.rooms?.forEach(roomData => { gridDiv.appendChild(createCube(roomData, false, floorData.label, monitorCounts, monitorsByLocation)); });
          floorData.corridors?.forEach(corridorData => { gridDiv.appendChild(createCube(corridorData, true, floorData.label, monitorCounts, monitorsByLocation)); });
          sectionDiv.appendChild(gridDiv); floorPlanContainer.appendChild(sectionDiv);
          if (index < schoolLayout.length - 1) { const divider = document.createElement('hr'); divider.className = 'section-divider'; floorPlanContainer.appendChild(divider); }
        });
      }

      function renderLostMonitors(lostMonitors) { /* 이전 위치 텍스트 수정 */
        lostMonitorsContainer.innerHTML = '';
        if (lostMonitors.length === 0) { lostMonitorsContainer.style.display = 'none'; return; }
        lostMonitorsContainer.style.display = 'block';
        const sectionDiv = document.createElement('div'); sectionDiv.className = 'floor-section';
        const labelDiv = document.createElement('div'); labelDiv.className = 'section-label'; labelDiv.textContent = `사라짐 (${lostMonitors.length})`; sectionDiv.appendChild(labelDiv);
        const groupedLostMonitors = lostMonitors.reduce((acc, monitor) => {
            const prevLocation = monitor.previous;
            if (!acc[prevLocation]) acc[prevLocation] = [];
            acc[prevLocation].push(monitor); return acc;
        }, {});
        const gridDiv = document.createElement('div'); gridDiv.className = 'lost-monitors-grid';
        Object.keys(groupedLostMonitors).sort().forEach(prevLocation => {
            const locationCube = document.createElement('div'); locationCube.className = 'lost-location-cube';
            const locationNameDiv = document.createElement('div'); locationNameDiv.className = 'lost-location-name';
            // 사라짐 섹션의 이전 위치 표시 텍스트 변경
            locationNameDiv.textContent = `[이전] ${prevLocation}`; // '[이전 위치]' -> '[이전]' 으로 축약
            locationCube.appendChild(locationNameDiv);
            const monitorListDiv = document.createElement('div'); monitorListDiv.className = 'lost-monitor-list';
            groupedLostMonitors[prevLocation].forEach(monitor => { monitorListDiv.appendChild(createMonitorCube(monitor, '사라짐')); });
            locationCube.appendChild(monitorListDiv); gridDiv.appendChild(locationCube);
        });
        sectionDiv.appendChild(gridDiv); lostMonitorsContainer.appendChild(sectionDiv);
        adjustRowHeights(); scaleLayout();
      }

      function scaleLayout() { /* 변경 없음 */
        const floorPlan = document.querySelector('.floor-plan'); if (!floorPlan) return;
        floorPlan.style.transform = 'scale(1)'; const containerWidth = floorPlan.scrollWidth; const windowWidth = window.innerWidth;
        const availableWidth = windowWidth - 40; let scale = 1;
        if (containerWidth > availableWidth) scale = availableWidth / containerWidth;
        document.querySelectorAll('.floor-plan').forEach(container => { container.style.transform = `scale(${scale})`; });
      }

      function debounce(func, wait) { /* 변경 없음 */
        clearTimeout(resizeTimeout); resizeTimeout = setTimeout(func, wait);
      }

      // PC Chrome, Firefox 환경인지 확인하는 함수
      function isDesktopChromeOrFirefox() {
        const platform = navigator.platform.toLowerCase();
        const userAgent = navigator.userAgent.toLowerCase();
        const isWindowsOrMac = platform.startsWith('win') || platform.startsWith('mac');
        const isChromeOrFirefox = userAgent.includes('chrome') || userAgent.includes('firefox');
        return isWindowsOrMac && isChromeOrFirefox;
      }

      async function generatePDF() { /* PDF 파일 이름 수정 및 폰트 변경 로직 추가 */
        downloadButton.disabled = true; refreshButton.disabled = true;
        pdfOverlay.querySelector('span').textContent = 'PDF 생성 준비 중...';
        pdfOverlay.classList.add('visible');
        document.body.classList.add('pdf-capture-mode');

        const useDefaultFont = !isDesktopChromeOrFirefox();
        if (useDefaultFont) {
          document.body.classList.add('pdf-default-font');
          let alertMessage = '';
          if (!(navigator.platform.toLowerCase().startsWith('win') || navigator.platform.toLowerCase().startsWith('mac'))) {
            alertMessage = '데스크탑 환경이 아니여서 기본 폰트가 적용됩니다.';
          } else if (!(navigator.userAgent.toLowerCase().includes('chrome') || navigator.userAgent.toLowerCase().includes('firefox'))) {
            alertMessage = `${navigator.userAgent.split('/')[0]}이(가) 아니라서 기본 폰트가 적용됩니다. (Chrome 또는 Firefox 브라우저를 권장합니다)`;
          } else {
            alertMessage = '기본 폰트가 적용됩니다.'; // 혹시 모를 다른 케이스
          }
          alert(alertMessage);
        } else {
          document.body.classList.remove('pdf-default-font'); // 혹시라도 남아있을 수 있는 클래스 제거
        }


        await new Promise(resolve => setTimeout(resolve, 100));

        try {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
            const pageWidth = pdf.internal.pageSize.getWidth(); const pageHeight = pdf.internal.pageSize.getHeight();
            const margin = 10; const contentWidth = pageWidth - margin * 2; const contentHeight = pageHeight - margin * 2; const sectionGap = 5;
            const sections = Array.from(document.querySelectorAll('.floor-section'));
            let capturedCanvases = [], sectionDimensions = [];

            pdfOverlay.querySelector('span').textContent = '레이아웃 캡처 중...';
            for (let i = 0; i < sections.length; i++) {
                const section = sections[i];
                const canvas = await html2canvas(section, { scale: 3, useCORS: true, logging: false, backgroundColor: '#ffffff', windowWidth: section.scrollWidth, windowHeight: section.scrollHeight });
                capturedCanvases.push(canvas); sectionDimensions.push({ width: canvas.width / 3, height: canvas.height / 3 });
            }

            let optimalScale = 1.0;
            sectionDimensions.forEach(dim => {
                const widthScale = dim.width > 0 ? contentWidth / dim.width : 1.0;
                const heightScale = dim.height > 0 ? contentHeight / dim.height : 1.0;
                optimalScale = Math.min(optimalScale, widthScale, heightScale);
            });

            let currentPageHeightUsed = margin; let isFirstSectionOnPage = true;
            pdfOverlay.querySelector('span').textContent = 'PDF 페이지 생성 중...';
            for (let i = 0; i < capturedCanvases.length; i++) {
                const canvas = capturedCanvases[i]; const originalWidth = sectionDimensions[i].width; const originalHeight = sectionDimensions[i].height;
                const finalWidth = originalWidth * optimalScale; const finalHeight = originalHeight * optimalScale;
                const requiredHeight = (isFirstSectionOnPage ? 0 : sectionGap) + finalHeight;
                if (!isFirstSectionOnPage && (currentPageHeightUsed + requiredHeight > pageHeight - margin)) { pdf.addPage(); currentPageHeightUsed = margin; isFirstSectionOnPage = true; }
                let positionY = currentPageHeightUsed; if (!isFirstSectionOnPage) { positionY += sectionGap; }
                const positionX = margin + (contentWidth - finalWidth) / 2;
                pdf.addImage(canvas.toDataURL('image/png'), 'PNG', positionX, positionY, finalWidth, finalHeight);
                currentPageHeightUsed = positionY + finalHeight; isFirstSectionOnPage = false;
            }
            // PDF 파일 이름 사용자 지정 이름으로 변경
            pdf.save('부광고등학교_모니터_현황.pdf');

        } catch (error) {
          console.error("PDF 생성 오류:", error); errorMessage.textContent = `PDF 생성 오류: ${error.message}`; errorMessage.style.display = 'block';
        } finally {
          pdfOverlay.classList.remove('visible'); document.body.classList.remove('pdf-capture-mode');
          document.body.classList.remove('pdf-default-font'); // PDF 생성 완료 후 클래스 제거
          setTimeout(() => { downloadButton.disabled = false; refreshButton.disabled = false; }, 300);
        }
      }

      refreshButton.addEventListener('click', loadAndRenderLayout);
      downloadButton.addEventListener('click', generatePDF);
      window.addEventListener('resize', () => debounce(scaleLayout, 250));

      buildValidLocations();
      loadAndRenderLayout();

    </script>
</body>
</html>
